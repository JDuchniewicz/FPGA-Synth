import argparse
import math

# not using numpy just because
class Generator:
    def __init__(self, args):
        self.args = args
        self.power = 2 ** int(self.args.r)
        self.hex_len = int(self.args.r) // 4

    def generate(self):
        if 'sine' in self.args.t:
            generate_sine()
    
    def generate_sine(self):
        size = int(self.args.n)
        print(self.hex_len)
        out = open(self.args.d, 'w')
        for sample in range(size):
            rad = (sample / size) * 2 * math.pi
            sine = math.sin(rad)
            shifted_sine = sine + 1 # we shift it up 1 and multiply by half of our possible range, resulting in -1 = 0,  0 = MAX / 21 = MAX
            sine_hex = '{0:0{1}x}'.format(int((self.power // 2) * shifted_sine), self.hex_len) # format specifier
            if self.args.q:
                out.write(sine_hex)
                pass
            else:
                print(sine_hex)
                print(sine)
                #idx_hex = hex(
                out.write(sine_hex + '\n')

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-t', choices=['sine'], help='type of wave to generate', required=True)
    parser.add_argument('-n', choices=['4096', '8192'], help='number of samples to be generated', required=True)
    parser.add_argument('-f', help='generate full period instead of quarter')
    parser.add_argument('-q', help='generate verilog ready lines of sequential logic')
    parser.add_argument('-d', help='output file', required=True)
    parser.add_argument('-r', default='16', help='output bits width')
    args = parser.parse_args()
    gen = Generator(args)     
    gen.generate_sine()

if __name__ == "__main__":
    main()

